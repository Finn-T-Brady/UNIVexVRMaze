{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\n\n\nfrom dataclasses import dataclass\n\n@dataclass\nclass node:\n    x: int\n    y: int\n    i: int\n    e: int = None\n\n\n@dataclass\nclass cache:\n    sides=[None,None,None,None]\n    def clear(self):\n        self.sides=[None,None,None,None]\n    def check(self,d):\n        f=drivetrain.heading(DEGREES)//90\n        if(d==LEFT):\n            f=f-1\n        if(d==RIGHT):\n            f=f+1\n        f=f%4\n        if(self.sides[f]==None):\n            drivetrain.turn_for(d,90,DEGREES,wait=True)\n            self.sides[f]=(distance.get_distance(MM)<SL/2)\n            drivetrain.turn_for(d,-90,DEGREES,wait=True)\n        return self.sides[f]\n    def ahead(self):\n        f=drivetrain.heading(DEGREES)//90\n        self.sides[f]=(distance.get_distance(MM)<SL/2)\n        return self.sides[f]\n\n#side length of grid\nSL=250#mm\n\ndef newNode():\n    return node(location.position(X,MM)//100,location.position(Y,MM)//100,drivetrain.heading(DEGREES))\n\ndef main():\n    nodes=[]\n    top=-1\n    sides=cache()\n    \"\"\"\n    #cheap left wall\n    while(not down_eye.detect(RED)):\n        drivetrain.turn_for(LEFT,90,DEGREES)\n        while(distance.get_distance(MM)<SL/2):\n            drivetrain.turn_for(RIGHT,90,DEGREES,wait=True)\n        drivetrain.drive_for(FORWARD,SL,MM)\n    \"\"\"\n\n    nodes.append(newNode())\n    top=top+1\n    brain.print(\"n\")\n\n    drivetrain.turn_for(LEFT,90,DEGREES,wait=True)\n    while(not down_eye.detect(RED)):\n        while(distance.get_distance(MM)<SL/2):\n            drivetrain.turn_for(RIGHT,90,DEGREES,wait=True)\n        brain.print(\"r\")\n\n        #check for backtrack\n        if(((drivetrain.heading(DEGREES)+180)%360)==nodes[top].i):\n            brain.print(\"b\")\n            top=top-1\n            nodes.pop()\n            sides.clear()\n            while(location.position(X,MM)//100 != nodes[top].x or location.position(Y,MM)//100 != nodes[top].y):\n                drivetrain.drive_for(FORWARD,SL,MM,wait=True)\n            drivetrain.turn_for(LEFT,90,DEGREES,wait=True)\n            continue\n        \n        nodes[top].e=drivetrain.heading(DEGREES)\n        b=False\n        while(not b and not down_eye.detect(RED)):\n            brain.print(\"t\")\n            drivetrain.drive_for(FORWARD,SL,MM)\n            sides.clear()\n            b=sides.ahead()\n            if(not b):\n                b=(not sides.check(LEFT))\n            if(not b):\n                b=(not sides.check(RIGHT))\n\n        nodes.append(newNode())\n        top=top+1\n        brain.print(\"n\")\n        i=0\n        c=False\n        while(i<top and not c):\n            c=nodes[top].x==nodes[i].x and nodes[top].y==nodes[i].y\n            i=i+1\n        if(c):\n            drivetrain.turn_for(LEFT,180,DEGREES,wait=True)\n            continue\n        if(not sides.check(LEFT)):\n            drivetrain.turn_for(LEFT,90,DEGREES,wait=True)\n    #victory lap\n    r=top\n    while(True):\n        brain.print(\"\\nreturning to home\")\n        while(r>0):\n            drivetrain.turn_to_heading(180+nodes[r].i,DEGREES)\n            r=r-1\n            while(location.position(X,MM)//100 != nodes[r].x or location.position(Y,MM)//100 != nodes[r].y):\n                    drivetrain.drive_for(FORWARD,SL,MM,wait=True)\n        brain.print(\"\\nreturning to goal\")\n        while(r<top):\n            drivetrain.turn_to_heading(nodes[r].e,DEGREES)\n            r=r+1\n            while(location.position(X,MM)//100 != nodes[r].x or location.position(Y,MM)//100 != nodes[r].y):\n                    drivetrain.drive_for(FORWARD,SL,MM,wait=True)\n\nvr_thread(main)\n","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.63.0","minVersion":"4.60.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null},"playground":"DynamicWallMaze","robotModel":"vr"}